---
layout: post
title: Jackrabbit in a cluster, some pitfalls
date: 2007-06-02 15:24:40.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  _oembed_fac555c214b780ac8596afb5fa46111e: "{{unknown}}"
  _oembed_8dbeffa24e81a6da4dc16646faadbd9f: "{{unknown}}"
author:
  login: iebtfdcouk
  email: ieb@tfd.co.uk
  display_name: Ian
  first_name: Ian
  last_name: Boston
permalink: "/2007/06/02/107/"
---
<p>Although jackrabbit in a cluster does work there are one of 2 issues with the 1.3 code base. There is a small patch that needs to be applied to the CusterNode implementation to make terminate the journal record.</p>
<p><code> </code></p>
<pre>@@ -637,6 +637,7 @@
record = journal.getProducer(PRODUCER_ID).append();
record.writeString(workspace);
write(record, nodeId);
+                      record.writeChar('ï¿½');
record.update();
setRevision(record.getRevision());
succeeded = true;</pre>
<pre>see <a href="https://issues.apache.org/jira/browse/JCR-915">https://issues.apache.org/jira/browse/JCR-915</a></pre>
<p>After that there is a race condition under load that is a larger patch described in <a href="https://issues.apache.org/jira/browse/JCR-929">https://issues.apache.org/jira/browse/JCR-929</a> which will cause the effective node to hang on requests into the JCR.  There are also some other things to note, in  MySQL clustered environment, you MUST have InnoDB as the default table type otherwise you will get collisions on the revision number.  In addition you must have the transaction issolation set to READ-COMMITTED, and not REPEATABLE-READ otherwise you will not see the changes propagate from one of the nodes to the other.</p>
