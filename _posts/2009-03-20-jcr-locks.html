---
layout: post
title: JCR Locks and Concurrent Modifications
date: 2009-03-20 00:56:27.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  _edit_last: '3991311'
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1241643782";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1241643783";}
  _oembed_339d77861f0d5945f7ecfd22a93c075d: "{{unknown}}"
  _oembed_6ebbb317567535152d00148b011bc9bf: "{{unknown}}"
  _oembed_e3e566212da851df649dcfa9d28ad420: "{{unknown}}"
  _oembed_dfe9065233eb50f766c55494de028606: "{{unknown}}"
  _oembed_a2ecd19f07356cfeb282af7e0e994631: "{{unknown}}"
  _oembed_4e43cc53182589f8f42a02cbcea48bbe: "{{unknown}}"
  _oembed_d65f1f228848c99c4483804b23515ef4: "{{unknown}}"
  _oembed_62fa45f07e381bed4d840f24bd9b09d5: "{{unknown}}"
  _oembed_c3de82df99f72d26469d7e60875d01de: "{{unknown}}"
  _oembed_b099be81b3fbf209ff9c556c6251f0d2: "{{unknown}}"
  _oembed_2ef914cf5abf3ae188b541d08b27789c: "{{unknown}}"
  _oembed_b12d65cc2d2025e937c28708c51a618b: "{{unknown}}"
  _oembed_d28594f833a6485b9010cbb17dc0823a: "{{unknown}}"
  _oembed_1c7aa6e171f81f42b1276690127ce2b8: "{{unknown}}"
  _oembed_8b82edb181000dc80e4ed1e8615c7502: "{{unknown}}"
  _oembed_36aeff0ad409919acbf557e040f96c76: "{{unknown}}"
  _oembed_97abd245080f3c49b50739a15ac21567: "{{unknown}}"
  _oembed_5eacea59787c7cbd35a3a754a1b7baf3: "{{unknown}}"
  _oembed_a2dcc840b9d3868f8f1e992fdf916ef0: "{{unknown}}"
author:
  login: iebtfdcouk
  email: ieb@tfd.co.uk
  display_name: Ian
  first_name: Ian
  last_name: Boston
permalink: "/2009/03/20/jcr-locks/"
---
<p>Heavy concurrent modification of a single node in Jackrabbit will result in InvalidItemStateException even with a transaction.<br />
The solution is to lock the node, the code below performs a database like lock on the node, timing out after 30s if no lock was obtained. The lock needs to be unlocked as its a cluster wide lock on the node.</p>
<p>I suspect however that the propagation rate will not be fast enough to maintain consistency over a cluster, but then again... nothing will be fast enough without impacting performance. The slightly annoying feature of this is that you <strong>must</strong> perform locking manually. This is IMVHO a bit crazy since at some point if you don't and you write to the node, you will get an exception, and if you are in a transaction (as you should be) you wont be able to recover the exception since it will require  rollback and a complete redo of the whole transaction.</p>
<pre>  public Lock getNodeLock(Node node) throws UnsupportedRepositoryOperationException,
      LockException, AccessDeniedException, RepositoryException {
    Lock lock = null;
    try {
      lock = node.getLock();
      if (lock.getLockToken() != null) {
        return lock;
      }
    } catch (LockException e) {
    }
    lock = null;
    long sleepTime = 100;
    int tries = 0;
    while (tries++ &lt; 300 ) {
      try {
        return node.lock(true, false);
      } catch (Exception ex) {
        if ( sleepTime &lt; 500 ) {
          sleepTime = sleepTime + 10;
        }
        try {
          if ( tries%100 == 0 ) {
            System.err.println(Thread.currentThread() + " Waiting for "+sleepTime+" ms "+tries);
          }
          Thread.sleep(sleepTime);
        } catch (InterruptedException e) {
        }
      }
    }
    throw new Error("Failed to lock node ");
  }</pre>
